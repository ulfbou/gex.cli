using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Gex.Generators;

/// <summary>
/// Source generator for creating static binders from annotated POCOs.
/// </summary>
[Generator]
public class BinderGenerator : IIncrementalGenerator
{
    private const string AttributeText = @"
namespace Gex.Core;

/// <summary>
/// Marks a class for binder generation.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class)]
public class GenerateBinderAttribute : System.Attribute
{
}
";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateBinderAttribute.g.cs",
            SourceText.From(AttributeText, Encoding.UTF8)));

        // Find all classes with the GenerateBinder attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine the selected classes with the compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate the source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is ClassDeclarationSyntax m && m.AttributeLists.Count > 0;

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }

                var attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                var fullName = attributeContainingTypeSymbol.ToDisplayString();

                if (fullName == "Gex.Core.GenerateBinderAttribute")
                {
                    return context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) as INamedTypeSymbol;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        var distinctClasses = classes.Where(c => c is not null).Cast<INamedTypeSymbol>().Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var classSymbol in distinctClasses)
        {
            if (classSymbol is null)
            {
                continue;
            }

            var source = GenerateBinderClass(classSymbol);
            context.AddSource($"{classSymbol.Name}Binder.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateBinderClass(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated binder for {className}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {className}Binder");
        sb.AppendLine("{");

        // Generate Bind method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Binds data to a {className} instance.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static {className} Bind(System.Collections.Generic.Dictionary<string, object?> data)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var instance = new {className}();");
        sb.AppendLine();

        foreach (var property in properties)
        {
            if (property.SetMethod != null)
            {
                sb.AppendLine($"        if (data.TryGetValue(\"{property.Name}\", out var {property.Name.ToLowerInvariant()}Value))");
                sb.AppendLine("        {");
                sb.AppendLine($"            instance.{property.Name} = ({property.Type.ToDisplayString()}){property.Name.ToLowerInvariant()}Value!;");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
        }

        sb.AppendLine("        return instance;");
        sb.AppendLine("    }");

        // Generate ToDictionary method
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Converts a {className} instance to a dictionary.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static System.Collections.Generic.Dictionary<string, object?> ToDictionary({className} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new System.Collections.Generic.Dictionary<string, object?>");
        sb.AppendLine("        {");

        for (int i = 0; i < properties.Count; i++)
        {
            var property = properties[i];
            var comma = i < properties.Count - 1 ? "," : "";
            sb.AppendLine($"            {{ \"{property.Name}\", instance.{property.Name} }}{comma}");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }
}
