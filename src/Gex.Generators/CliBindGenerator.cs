// -----------------------------
// Source-generator (reference implementation)
// -----------------------------
// NOTE: For real usage, move this class into a separate analyzer project (netstandard2.0).
// The generator below is an incremental generator that discovers classes annotated with [CliBind]
// and emits a static binder method Bind_ClassName(ParseResult).

#if INCLUDE_GENERATOR
// To compile the generator in the same file, define INCLUDE_GENERATOR and add Roslyn references.
// In practice, keep the generator in its own project.
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Gex.Generators;

[Generator]
public class CliBindGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                {
                    var cds = (ClassDeclarationSyntax)ctx.Node;
                    var model = ctx.SemanticModel;
                    var symbol = model.GetDeclaredSymbol(cds) as INamedTypeSymbol;
                    if (symbol == null) return null;
                    foreach (var attr in symbol.GetAttributes())
                    {
                        if (attr.AttributeClass?.ToDisplayString() == "Gex.Core.CliBindAttribute")
                            return symbol;
                    }
                    return null;
                })
            .Where(static s => s is not null)
            .Select((s, _) => s!);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var compilation = source.Left;
            var classes = source.Right;
            if (classes.IsDefaultOrEmpty) return;

            foreach (var cls in classes.Distinct(SymbolEqualityComparer.Default))
            {
                try
                {
                    var ns = cls.ContainingNamespace.IsGlobalNamespace ? "" : cls.ContainingNamespace.ToDisplayString();
                    var className = cls.Name;
                    var binderName = $"__Gex_Bindings_{className}";
                    var sb = new StringBuilder();
                    sb.AppendLine("// <auto-generated/>\nusing System;");
                    if (!string.IsNullOrEmpty(ns)) sb.AppendLine($"namespace {ns} {{");
                    sb.AppendLine($"internal static class {binderName} {{");
                    sb.AppendLine($"    public static {cls.ToDisplayString()} Bind_{className}(Gex.Core.ParseResult result) {{");
                    sb.AppendLine($"        var obj = new {cls.ToDisplayString()}();");

                    foreach (var prop in cls.GetMembers().OfType<IPropertySymbol>())
                    {
                        var propName = prop.Name;
                        var key = propName.ToLowerInvariant();
                        var propType = prop.Type.ToDisplayString();
                        sb.AppendLine($"        var v_{propName} = result.GetValue(\"{key}\");");
                        sb.AppendLine($"        if (v_{propName} != null) {{");
                        if (prop.Type.SpecialType == SpecialType.System_String)
                        {
                            sb.AppendLine($"            obj.{propName} = v_{propName};");
                        }
                        else if (prop.Type.SpecialType == SpecialType.System_Int32)
                        {
                            sb.AppendLine($"            if (int.TryParse(v_{propName}, out var tmp_{propName})) obj.{propName} = tmp_{propName};");
                        }
                        else if (prop.Type.SpecialType == SpecialType.System_Boolean)
                        {
                            sb.AppendLine($"            if (bool.TryParse(v_{propName}, out var tmp_{propName})) obj.{propName} = tmp_{propName};");
                        }
                        else
                        {
                            sb.AppendLine($"            try {{ obj.{propName} = ({propType})Convert.ChangeType(v_{propName}, typeof({propType})); }} catch {{ }}");
                        }
                        sb.AppendLine($"        }}");
                    }

                    sb.AppendLine($"        return obj;");
                    sb.AppendLine("    }");
                    sb.AppendLine("}");
                    if (!string.IsNullOrEmpty(ns)) sb.AppendLine("}");

                    spc.AddSource($"{binderName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    var diag = Diagnostic.Create(new DiagnosticDescriptor(
                        id: "GEXGEN001",
                        title: "CliBindGenerator error",
                        messageFormat: $"Generator error: {ex.Message}",
                        category: "Gex.Generators",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true), Location.None);
                    spc.ReportDiagnostic(diag);
                }
            }
        });
    }
}
#endif
